main = 0.0 ;

interface à¤½à§ˆÂ­  {
mut method @@@@á°¡ áƒ‡à¨¼(mut à¤½à§ˆÂ­ this);

read method imm Î† êª‰á’á¯¦(read à¤½à§ˆÂ­ this, imm ê£»à±–áª°âƒ‘à¼¾àº± á¯”à·ŠÜ¶);
}

capability class Std  {
read method imm Number add(read Std this, imm Number a, imm Number b) =
0 ;

mut method imm Float randomFloat(mut Std this, imm Number min, imm Number max) =
0.0 ;

mut method @Bool sleep(mut Std this, imm Int timeMs) =
@[];

read method imm Number sub(read Std this, imm Number a, imm Number b) =
0 ;

mut method mut Std print(mut Std this, imm String msg) =
this;

read method imm Number mul(read Std this, imm Number a, imm Number b) =
0 ;

read method imm Bool gte(read Std this, imm Number a, imm Number b) =
new False();

read method imm String concat(read Std this, imm String a, imm String b) =
a;
}

interface â„‚ extends à»†  {
read method @à®™ à¹…(read â„‚ this, capsule à³± á”);
}

interface àºŠï¸Š extends à»†àº¸, à®, â¶à«à§«, ã€†á¨›, áŒ, à«±, à¦Œà©¯  {
mut method @ï¹© à¯(mut àºŠï¸Š this);

imm method @áƒ¶àº¼âƒ°áª à²—(imm àºŠï¸Š this);
}

interface êª±à³¢á² extends â‚œá«á¨›àª¼, ã€³á¥Œá·Œê«¯  {

}

interface ï¿„ extends à©šà«¼  {

}

class True implements Bool  {
imm method imm Bool not(imm True this) =
new False();

imm method imm Bool or(imm True this, imm Bool b) =
this;

imm method imm Bool and(imm True this, imm Bool b) =
b;

imm method imm String toString(imm True this) =
"true";

imm method imm ProducerN thenElse(imm True this, imm ProducerN f1, imm ProducerN f2) =
f1;
}

interface String extends Literal  {

}

class False implements Bool  {
imm method imm Bool not(imm False this) =
new True();

imm method imm Bool or(imm False this, imm Bool b) =
b;

imm method imm Bool and(imm False this, imm Bool b) =
this;

imm method imm String toString(imm False this) =
"false";

imm method imm ProducerN thenElse(imm False this, imm ProducerN f1, imm ProducerN f2) =
f2;
}

interface Int extends Number, Literal  {

}

class Ë® implements àº§, á³ª  {
@@@@@à¡† ï¿¦áª“;
capsule ê“µ à ¤;imm method imm ê¬£à´¼ êª¢à»˜(imm Ë® this) =
head(tail(60.3 ));

imm method imm ï¬à¿†á®¹á¥ êš™à·³êª°(imm Ë® this) =
êªà«¼áœ²ê›±;
}

capability class á±á‚“à § implements à¥´ê›±  {
imm method capsule à­± ï¶¶(imm á±á‚“à § this) =
head(tail(@@â„• ã…• = @[],
302 ));

imm method @×± à­±ê«¯àµ†(imm á±á‚“à § this, @ê®… á¡, @á¹Š Î‰á°«) =
0.9375 ;

imm method imm à¨¸ à®áª‘à±‡(imm á±á‚“à § this, imm àª² â„¦, @@àº à®©à«®) =
imm â¶¦ à¯¹ = @[],
@[tail(head(ê¤)); "ğ‘´»\uCBB4"];

read method @à²¹ ï¹àª¾à¼µ(read á±á‚“à § this) =
head(á¼˜à¾†áª¼);
}

interface Float extends Number, Literal  {

}

interface Number extends Literal  {

}

interface Bool extends Literal  {
imm method imm Bool not(imm Bool this);

imm method imm Bool or(imm Bool this, imm Bool b);

imm method imm Bool and(imm Bool this, imm Bool b);

imm method imm ProducerN thenElse(imm Bool this, imm ProducerN f1, imm ProducerN f2);
}

capability class ã„•áˆ  {
@á‹” ï½‡ê©ƒ;
@@àºê§™ à®š;imm method capsule à°½Ö¿à¯‚à¯ª á­(imm ã„•áˆ this) =
"\70\51\uuuu3eC0ğŸ„\r\135ğ‘µª";
}

class á±¹ê¨¯á·¼á‚‹ implements ê¬¢á©–á¨›  {
capsule method imm ê«›Â• êœ—(capsule á±¹ê¨¯á·¼á‚‹ this, @@@@ê©ª ê¦•àº¼à°‚, @@ãƒ¼ à±¡êšŸà®£, @Öáªƒá©¬ ï¿¥à©á­‘ê©˜á™ï¿¹ê¦ƒà¤») =
tail(@[]);

read method imm â„‡á§ à¡ª(read á±¹ê¨¯á·¼á‚‹ this) =
@[];

imm method @@ê©¨á¢© à¤½(imm á±¹ê¨¯á·¼á‚‹ this, @âµ‹ à­ ) =
@[1 ; @[]];
}

interface Literal  {
imm method imm String toString(imm Literal this);
}

capability class Ş±à¶ƒá³™ implements íŸµê¤«ê™¯  {
imm ê§ Î•;imm method @@@à²‹ íŸ…à¶‚ê©Œà­‹(imm Ş±à¶ƒá³™ this, @@ï©´×‡ï¼™ à¶ à³†, @@âµ¯ â·êª²) =
1 ;

read method @à±¡á­‘ á‘(read Ş±à¶ƒá³™ this) =
0 ;

imm method @Ù á‰Œ(imm Ş±à¶ƒá³™ this) =
tail(head(new ï¾š(tail(this), @á½à¾†áª”à± áºê¤…à«£ = áŠ¥,
this, head(384 ), tail(tail(3 )), áŠ­á±†à¥£à²‚, 0.0 , ã‚¥ê©ƒê †ï¿»ê¯²à°´, "\'ğ‘ƒºá‰—á®", this.á¦à­– = å…­ï¾», @[], @[], 0 )));
}

capability class à»†àµ€ implements â„‡, à°¬, â„¨à¼©  {

}

interface ProducerN  {
imm method imm Number get(imm ProducerN this);
}

